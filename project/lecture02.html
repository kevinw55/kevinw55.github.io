<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>L02 - Formal Language Theory</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="/assets/css/styles.css">
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>



  </head>
  <body>
      <!-- Navigation Bar -->
      <nav class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark" >
    <div class="container">
        <div class="navbar-brand">Kevin Wilson</div>
        <button class="navbar-toggler" type="button" data-toggle="collapse" 
                data-target="#navbarList" aria-controls="navbarList" 
                aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
        </button>
        <div class="navbar-collapse collapse" id="navbarList">
            <ul class="navbar-nav mr-auto"></ul>
            <ul class="navbar-nav navbar-right">
            
                <li class="nav-item">
                    <a class="nav-link" href="/" >Home</a>
                </li>
            
                <li class="nav-item">
                    <a class="nav-link" href="/history.html" >History</a>
                </li>
            
                <li class="nav-item">
                    <a class="nav-link" href="/project.html" >Project</a>
                </li>
            
                <li class="nav-item">
                    <a class="nav-link" href="/exampapers.html" >Exam Papers</a>
                </li>
            
            </ul>
        </div>    <!-- /.navbar-collapse -->
    </div>  <!-- /.container -->
</nav>



      <!-- End Navigation Bar -->
      <!-- Content -->
      <div class="container" id="projarticle-page">
<article>
     <header class='article-header'>
        <div>
          <div class='thumb'>
            <div class='post-rubric'>
            <div class='lecture-num'>Lecture 02</div>
              <div class='post-title'>L02 - Formal Language Theory</div>
              <div class='post-meta'>
                <div class='tags'>
                  
                </div>
              </div>   <!-- post-meta -->
            </div>   <!-- post-rubric -->
          </div>     <!-- thumb  -->
            </div>  <!-- container --> 
         <div class='clear'></div>   
        <div class='description'>
          Theoretical Background
        </div>    <!-- description -->
      </header>

    <div class='article-post'>
      <div><!-- 12 -->
<h1 id="formal-language-theory">Formal Language Theory</h1>

<p>We try to split the issues of the formal structure of a program from any questions of what programs might mean.</p>

<p>We certainly need answers to the following questions:</p>

<ol>
  <li>
    <p>How are characters structured into words (Lexical question).</p>
  </li>
  <li>
    <p>How are words structured into programs (Parser question).</p>
  </li>
  <li>
    <p>Is program P grammatically legal?</p>
  </li>
  <li>
    <p>What are the proper subcomponents of program P?  What are the proper subcomponents of the subcomponents, and so on.</p>
  </li>
</ol>

<!-- 13 -->
<h1 id="history--motivation">History &amp; Motivation</h1>

<h2 id="chomsky-1950s">Chomsky (1950s)</h2>

<p>Adapted the production systems of Eric Post for the analysis of languages.  <strong>Transformation Grammar</strong> was developed to give precise description to the striking features of language.</p>

<h2 id="computer-science-1960s">Computer Science (1960s)</h2>

<p>Borrowing Chomsky’s ideas defined ALGOL-60 by a <strong>Context-Free</strong> grammar.  This leads to syntax directed compilation and automatic generation of parsers.</p>

<h2 id="the-problem">The problem</h2>

<p>To go from a concrete representation of the program (the source code as processed by the Lexical analysis phase) to an abstract representation (a parse tree).</p>

<!-- 14 -->
<h3 id="concrete-syntax">Concrete Syntax</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x := a + 24;
</code></pre></div></div>

<p>Grammatical structure is IMPLICIT</p>

<h3 id="abstract-syntax">Abstract Syntax</h3>

<!-- Image -->
<p><img class="centre" src="/assets/project/theory/L02P014A_AbstractSyntax.png" alt="Lecture 02 Image 01" /></p>

<p>Grammatical structure is EXPLICIT</p>

<h3 id="typical-implementation">Typical Implementation</h3>

<!-- Image -->
<p><img class="centre" src="/assets/project/theory/L02P014B_TypicalImplementation.png" alt="Lecture 02 Image 02" /></p>

<p>t      type (s.assign)<br />
s      size (number of components)<br />
c      continuation (flow of control)<br />
\(p_i\)      proper subcomponents (similar nodes)</p>

<!-- 15 -->
<h3 id="example">Example</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>begin
     int x, y;
     proc f(): print "CC324*C*L";
     x := 4;
  l: y := 5;
     x := 2
end
</code></pre></div></div>

<!-- Image -->
<p><img class="centre" src="/assets/project/theory/L02P015A_Example.png" alt="Lecture 02 Image 03" /></p>

<p>Black Arrow     - Proper Subcomponents<br />
Red Arrow     - Entries in the Symbol Structure<br />
Orange Arrow     - Continuation</p>

<p>Continuation isn’t a syntax issue.  It’s purely to do with interpreters, since compilers just execute the code.  The interpreter must execute straight from the parse tree.</p>

<!-- 16 -->
<h3 id="definition">Definition</h3>

<p>A Grammar \(G\) is a quadruple</p>

<p>\(G = \{ N, T, P, s \} \)</p>

<p>where</p>

<p>\( N \) is a finite set of nonterminals</p>

<p>\( T \) is a finite set of terminals</p>

<p>\( P \) is a finite set of productions</p>

<p>\( s \in N \) is the start symbol</p>

<p>\( N \cap T = \varnothing    \hspace{20mm} \)  \( N \) and  \( T \) are completely different sets</p>

<p>Let \( S = N \cup T  \hspace{20mm} \) Symbols</p>

<p>Recall \( S^* \) is set of all finite sequences of symbols (including the empty set)</p>

<p>\( P \subseteq  S^* N S^* \times S^*  \)</p>

<p>i.e. the productions are pairs \( &lt;\alpha, \beta&gt; \) of sequences of symbols.</p>

<p>\( \alpha \) cannot be empty and must contain at least one nonterminal.</p>

<p>We will write \( &lt;\alpha, \beta&gt; \) as \( \alpha \rightarrow \beta  \)</p>

<p>The cross product of two sets is a pair such that one member is a member of one set, and the other a member of the other.</p>

<!-- 17 -->
<h3 id="definition-1">Definition</h3>

<p>Let \( G = \{ N, T, P, s \} \) This is the particular grammar we are working with</p>

<p>Let \( S = N \cup T \)</p>

<p>Let \( \alpha, \beta, \gamma, \delta \in S^* \hspace{20mm} \)  (are all sequences of symbols)</p>

<p>then</p>

<p>\( \gamma \alpha \delta \underset{G}{\Rightarrow} \gamma \beta \delta \hspace{10mm} \Leftrightarrow_{def} \hspace{10mm} \alpha \rightarrow \beta \in P \hspace{20mm} \) (we can replace any \( \alpha \) with \( \beta \) )</p>

<p>Read \( \underset{G}{\Rightarrow} \) as “directly derives in G”</p>

<h3 id="definition-2">Definition</h3>

<p>Let \( \alpha, \alpha_1, \alpha_2, \alpha_3, …., \alpha_n, \beta \in S^* \)</p>

<p>then</p>

<p>\( \alpha \underset{G}{\Rightarrow}^+ \beta \hspace{10mm} \Leftrightarrow_{def} \)</p>

<p>\( \qquad \alpha \underset{G}{\Rightarrow} \alpha_1 \)
\( \quad \land \quad \)
\( \alpha_1 \underset{G}{\Rightarrow} \alpha_2 \)
\( \quad \land \quad \)
\( \dots  \)
\( \quad \land \quad \)
\( \alpha_{n-1} \underset{G}{\Rightarrow} \alpha_n \)
\( \quad \land \quad \)
\( \alpha_n \underset{G}{\Rightarrow} \beta  \)</p>

<p>Also:</p>

<p>\( \alpha \underset{G}{\Rightarrow}^* \beta \hspace{10mm} \Leftrightarrow \hspace{10mm} \alpha \Rightarrow^+ \beta \quad \lor \quad \alpha = \beta \)</p>

<p>Read \( \underset{G}{\Rightarrow}^* \) as “derives in G”</p>

<h3 id="summary">Summary</h3>

<p>\( \Rightarrow^* \quad \) derives in no steps or more</p>

<p>\( \Rightarrow^+ \quad \) derives in one step or more</p>

<p>\( \Rightarrow \quad \) derives in one step exactly</p>

<!-- 18 -->

<p>For the cognoscenti:</p>

<p>\( \Rightarrow^+ \) is the <u>transitive closure</u> of \( \Rightarrow \)</p>

<p>\( \Rightarrow^* \) is the <u>reflexive transitive closure</u> of \( \Rightarrow \)</p>

<p>Where possible we will write \( \underset {G} {\Rightarrow} \) as \( \Rightarrow \)</p>

<p>Recall</p>

<p>\( G = \{ N, T, P, s \} \)</p>

<p>then</p>

<p>\( \{ \alpha | s \Rightarrow^* \alpha \} \) are the SENTENTIAL FORMS of \( G \)</p>

<p>Also</p>

<p>\( \{ \alpha | s \Rightarrow^* \alpha  \land \alpha \in T^* \} \) are the SENTENCES of \( G \)</p>

<p>We define the LANGUAGE generated by \( G \) to be precisely the sentences:</p>

<p>\( L(G) = \{ \alpha | s \underset {G}{\Rightarrow}^* \alpha  \land \alpha \in T^* \}  \)</p>

<!-- 19 -->

<h3 id="example-1">Example</h3>

<p>Let \( G = \{ \overset {N}{ \{s\} } , \overset {T} { \{0, 1\} } , \overset {P} { \{s \rightarrow 0 s 1, s \rightarrow 01 \} }, \overset {s}{ s } \}   \)</p>

<p>Only by iteratively applying the first production can we get chains of derivation - eg:</p>

<p>\( s \Rightarrow 0 s 1 \hspace{3em} ( s \rightarrow 0 s 1 )  \)</p>

<p>\( s \Rightarrow 00 s 11 \hspace{2em} ( s \rightarrow 0 s 1 )  \)</p>

<p>\( s \Rightarrow 000 s 111 \hspace{1em} ( s \rightarrow 0 s 1 )  \)</p>

<p>\( … \)</p>

<p>\( s \Rightarrow 0^n 1^n \hspace{3em} ( s \rightarrow 01 )  \)</p>

<p>A bit of informal reasoning allows us to conclude that:</p>

<p>\( L(G) = \{ 0^n 1^n \enspace | \enspace n \geqslant 1 \} \)</p>

<p>Note that</p>

<p>\( t^i = \underbrace {tt…t}_{i \  times} \)</p>

<p>and that</p>

<p>\( t^0 = &lt;&gt; \)</p>

<!-- 20 -->

<h3 id="another-example">Another example</h3>

<p>Let</p>

<p>\( G = \{ \overset {N}{ \{ a,b,c \} } , \overset {T} { \{ 0,1,2 \} } , \overset {P} { \{P \} }, \overset {s}{ a } \}   \)</p>

<p>\( P = \{ \)</p>

<p>\( \qquad a \rightarrow 0 abc \hspace{3em} : 1 \)</p>

<p>\( \qquad a \rightarrow 0 bc \hspace{4em}  : 2 \)</p>

<p>\( \qquad cb \Rightarrow bc \hspace{4em} : 3  \)</p>

<p>\( \qquad 0b \Rightarrow 01 \hspace{4em} : 4  \)</p>

<p>\( \qquad 1b \Rightarrow 11 \hspace{4em} : 5  \)</p>

<p>\( \qquad 1c \Rightarrow 12 \hspace{4em} : 6  \)</p>

<p>\( \qquad 2c \Rightarrow 22 \quad \} \hspace{3em}  : 7   \)</p>

<p>Apply:</p>

<p>1 : n-1 times   \( \hspace{1.5em} a \Rightarrow^* \enspace 0^{n-1} a (bc)^{n-1} \)</p>

<p>2 : once        \( \hspace{3em} a \Rightarrow^* \enspace 0^n (bc)^n \)</p>

<p>3 : ? times     \( \hspace{2em} a \Rightarrow^* \enspace 0^n b^n  c^n \)</p>

<p>4 : once        \( \hspace{3em} a \Rightarrow^* \enspace 0^n b^{n-1}  c^n \)</p>

<p>5 : n-1 times   \( \hspace{1.5em} a \Rightarrow^* \enspace 0^n 1^n  c^n \)</p>

<p>6 : once        \( \hspace{3em} a \Rightarrow^* \enspace 0^n 1^n  2 c^{n-1} \)</p>

<p>7 : n-1 times   \( \hspace{1.5em} a \Rightarrow^* \enspace 0^n 1^n  c^n \)</p>

<p>\( L(G) = \{ 0^n 1^n 2^n \enspace | \enspace n \geqslant 1 \} \)</p>

<p>Note that the productions must have at least one nonterminal on the left hand side.</p>

<!-- 21 -->

<h3 id="definition-3">Definition</h3>

<p>\( G_1 \equiv G_2 \Leftrightarrow_{def} L(G_1) = L(G_2)  \)</p>

<p>That is: two grammars  are equivalent precisely when the language they produce are the same.</p>

<h3 id="notation-for-p">Notation (for P)</h3>

<p>Backus-Naur-form (BNF)</p>

<p>non-terminals appear in angle brackets &lt; &gt;.</p>

<p>terminals just appear as themselves.</p>

<p>if \( \qquad &lt; \alpha, \beta &gt; \in P \qquad \) then we write \( \qquad \alpha ::= \beta \)</p>

<p>if \( \qquad &lt; \alpha, \beta_i &gt; \in P \qquad \) for \( i \geqslant 0 \qquad \) we write \( \qquad \alpha ::= \beta_1 | \beta_2 | \beta_3 | … | \beta_i \)</p>

<p>BNF is used, in fact, only when \( \alpha \in N \)</p>

<!-- 21a again -->

<h2 id="types-of-grammar">Types of Grammar</h2>

<p>By adding constraints on the definition we define the following:</p>

<p>( \( | \alpha | \) means the length of sequence \( \alpha \)  )</p>

<h3 id="type-0">TYPE 0</h3>

<p>no restrictions</p>

<h3 id="type-1">TYPE 1</h3>

<p>Where</p>

<p>\( | \beta | \geqslant | \alpha | \) when \( \alpha \rightarrow \beta \)</p>

<p>or alternatively:</p>

<p>if</p>

<p>\( \beta, \gamma, \delta \in S^* \qquad \&amp; \qquad \eta \in N \qquad \&amp; \qquad \beta \neq &lt;&gt; \)</p>

<p>then</p>

<p>\( \gamma \eta \delta \rightarrow \gamma \beta \delta \qquad \)</p>

<p>In other words it is only replaceable when surrounded with \( \gamma \) and \( \delta \).</p>

<p>This suggests the name CONTEXT SENSITIVE GRAMMAR.</p>

<h3 id="type-2">TYPE 2</h3>

<p>Where</p>

<p>\( | \alpha | = 1, \qquad \alpha \in N, \qquad \beta \neq &lt;&gt; \)</p>

<p>This suggests the name CONTEXT FREE GRAMMAR.</p>

<h3 id="type-3">TYPE 3</h3>

<p>Where</p>

<p>\( \alpha \rightarrow t\beta \qquad or \qquad \alpha \rightarrow t \)</p>

<p>is the form of all productions such that:</p>

<p>\( | \alpha | = 1 ,\qquad \alpha \in N, \qquad t \in T, \qquad \beta \in N \)</p>

<!-- 22 -->

<h2 id="specifying-p">SPECIFYING P</h2>

<p>(Almost always type 2 or type 3)</p>

<p>\( &lt; E &gt; ::= &lt; E &gt; + &lt; T &gt; | &lt; T &gt; \)</p>

<p>sometimes as</p>

<p>\( E \rightarrow E+T \enspace | \enspace T \)</p>

<h4 id="nature-of-productions">Nature of productions</h4>

<p>\( E \rightarrow E+T \enspace | \enspace T \qquad \) (left recursive)</p>

<p>\( E \rightarrow T+E \enspace | \enspace T \qquad \) (right recursive)</p>

<p>\( E \rightarrow T[+T]^* \qquad \) (iterative)</p>

<p>\( [x]^* \) means zero or more occurrences.</p>

<h4 id="syntax-diagrams">Syntax Diagrams</h4>

<!-- Diagram -->

<!-- 23 -->

<h3 id="example---type-2-context-free-grammar">Example - Type 2 Context Free Grammar</h3>

<p>\( G = \{ \overset {N}{ \{ E,T,F \} } , \overset {T} { \{ i,+,*,(,) \} } , \overset {P} { \{P \} }, \overset {s}{ E } \}   \)</p>

<p>\( P = \{ \)</p>

<p>\( \qquad E \rightarrow E + T \enspace | \enspace T \hspace{4em} : 1,2 \)</p>

<p>\( \qquad T \rightarrow T * F \enspace | \enspace F \hspace{4em}  : 3,4 \)</p>

<p>\( \qquad F \rightarrow ( E ) \enspace | \enspace i \qquad \} \hspace{3em} : 5,6  \quad  \)</p>

<p>Derivation as follows:</p>

<p>\( E \Rightarrow T \hspace{6em} by \quad 2 \)</p>

<p>\( E \Rightarrow T * F \hspace{5em} by \quad 3 \)</p>

<p>\( E \Rightarrow F * F \hspace{5em} by \quad 4 \)</p>

<p>\( E \Rightarrow i * F \hspace{5em} by \quad 6 \)</p>

<p>\( E \Rightarrow i * ( E ) \hspace{5em} by \quad 5 \)</p>

<p>\( E \Rightarrow i * ( E + T ) \hspace{3em} by \quad 1 \)</p>

<p>\( E \Rightarrow i * ( T + T ) \hspace{3em} by \quad 2 \)</p>

<p>\( E \Rightarrow i * ( F + T ) \hspace{3em} by \quad 4 \)</p>

<p>\( E \Rightarrow i * ( i + T ) \hspace{3em} by \quad 6 \)</p>

<p>\( E \Rightarrow i * ( i + F ) \hspace{3em} by \quad 4 \)</p>

<p>\( E \Rightarrow i * ( i + i ) \hspace{3em} by \quad 6 \)</p>

<p><br /></p>

<p>\( E \underset {G} {\Rightarrow}^*  i * ( i + i )  \)</p>

<!-- 24 -->

<h2 id="derivation-trees">DERIVATION TREES</h2>

<p>We can describe a derivation in a Context Free Grammar by means of a tree.</p>

<p>A TREE is a pair \( \lt N, E \gt \) where:</p>

<p>\(N\) is a finite set of nodes</p>

<p>\(E\)  is a finite set of edges</p>

<p>Edges are ordered pairs of nodes:</p>

<p>\( \lt n_1 , n_2 \gt \hspace{3em} n_1, n_2  \in N \)</p>

<h4 id="constraints">Constraints:</h4>

<p>1) There exists precisely one node \(n\) such that there does not exist an edge \( \lt n^\prime, n \gt \) for some \( n^\prime \).  (n is the ROOT)</p>

<p>2) for every \( n \in N \) there exists a sequence of edges:</p>

<p>\( \lt r, n_1 \gt \lt n_1, n_2 \gt \dots \lt n_i-1, n_i \gt \dots \lt n_u, n \gt   where (u \geqslant 0)  \)</p>

<p>This says the tree is connected.  This is implied by rule 1 and this constraint is redundant.</p>

<p>3) if \( \hspace{2em} \lt n^\prime, n \gt , \lt n^{\prime\prime}, n \gt \in E \hspace{2em}\) then \( \hspace{2em} n^\prime = n^{\prime\prime} \)</p>

<p>(Exactly one edge enters every node - no loops)</p>

<!-- 24 again -->

<p>We construct a derivation tree from a derivation in a CFG (type 2) as follows:</p>

<p>1)  Set \( N_0 = \{r\}, E_0 = \{\} \)</p>

<p>( \(r\) is a node labelled s )</p>

<p>2) For  \( \quad i \gt 0 \quad \) let</p>

<p>\( \alpha N \beta \Rightarrow \alpha \gamma \beta \)</p>

<p>be the \( i^{th}\)  line of the derivation.</p>

<p>\( | \gamma | = n \hspace{3em} \gamma = s_1 \dots s_n  \)</p>

<p>Let \( \lt N_{i-1}, E_{i-1} \gt \) be the derivation tree for the first \( i-1 \) lines:</p>

<p>Set \( \quad N_i = N_{i-1} \cup \Sigma \quad and \quad E_i = E_{i-1} \cup \Pi  \)</p>

<p>where</p>

<p>\( \Sigma \) is a set of \(n\) new nodes labelled \(s_1 \dots s_n \)</p>

<p>and</p>

<p>\( \Pi \) is a set of \(n\) edges</p>

<p>\( \lt q, \sigma_1 \gt \dots \lt q, \sigma_n \gt \)</p>

<p>where</p>

<p>\( \sigma_1, \dots, \sigma_n \in \Sigma \)</p>

<p>\( q \in N_{i-1} \) is the node corresponding to the nonterminal \(N\)</p>

<!-- 25 -->

<h2 id="things-you-can-do">THINGS YOU CAN DO</h2>

<p>1) Check that the resulting \( \lt N, E \gt \) is a tree.</p>

<p>2) Show that \( q \in N_{i-1} \) used in the construction always exists.</p>

<p>3) This construction shows that the existence of a derivation implies the existence of a derivation tree.  Show that the existence of a derivation tree implies the existence of a derivation.</p>

<p>1 &amp; 2 are crucial parts of the constructive proof.</p>

<p>3 means we can always draw graphs without fear that they don’t correspond to any derivation.</p>

<!-- 26 -->

<h2 id="example-2">EXAMPLE</h2>

<p>\( G = \{  \{ A,B \} , \{ a,b \} , P , A \} \)</p>

<p>\( P = \{ A \rightarrow aBA \enspace | \enspace a \)</p>

<p>\( \qquad B \rightarrow AbB \enspace | \enspace AA \enspace | \enspace ba \enspace \} \)</p>

<h3 id="a-derivation">A Derivation:</h3>

<p>\( A \Rightarrow aBA \)</p>

<p>\( \quad \Rightarrow aAbBA \)</p>

<p>\( \quad \Rightarrow aabBA \)</p>

<p>\( \quad \Rightarrow aabbaA \)</p>

<p>\( \quad \Rightarrow aabbaa \)</p>

<h3 id="its-tree">It’s tree</h3>

<!-- Diagram here -->

<!-- 27 -->

<h2 id="ambiguity">AMBIGUITY</h2>

<p>A CFG \( \enspace G \enspace \) is AMBIGUOUS iff there exists more than one distinct derivation of any sentence in \( L(G) \)</p>

<p>(hence two or more derivation trees)</p>

<h3 id="example-3">EXAMPLE</h3>

<p>\( G = \{  \{ E \} , \{ i,*,+ \} , P , E \} \)</p>

<p>\( P = \{ \enspace E \rightarrow E  +  E \)</p>

<p>\( \qquad \quad E \rightarrow E  *  E \)</p>

<p>\( \qquad \quad E \rightarrow i \)</p>

<p>\( \qquad \} \)</p>

<h3 id="consider">consider:</h3>

<p>\( E \Rightarrow E + E \)</p>

<p>\( \quad \Rightarrow i + E \)</p>

<p>\( \quad \Rightarrow i + E * E \)</p>

<p>\( \quad \Rightarrow i + i * E \)</p>

<p>\( \quad \Rightarrow i + i * i \)</p>

<p>\( E \Rightarrow E * E \)</p>

<p>\( \quad \Rightarrow E + E * E \)</p>

<p>\( \quad \Rightarrow i + E * E \)</p>

<p>\( \quad \Rightarrow i + i * E \)</p>

<p>\( \quad \Rightarrow i + i * i \)</p>

<p>we can see this more clearly from their graphs …</p>

<!-- 28 -->

<!-- Diagram here -->
<p><img class="centre" src="/assets/project/theory/L02P028A_Ambiguous1.png" alt="Lecture 02 Image Page 28A" /></p>

<!-- Diagram here -->
<p><img class="centre" src="/assets/project/theory/L02P028B_Ambiguous2.png" alt="Lecture 02 Image Page 28B" /></p>

<p>3 + 4 * 2 = 11</p>

<p>or is it 14 ??!!</p>

<p>We need to do something about this!</p>

<p>It isn’t possible to write a program which will say, for any kind of grammar, if it is ambiguous.</p>

<!-- 29 -->

<h2 id="chain-and-full-reduction-of-derivation-trees">CHAIN AND FULL REDUCTION OF DERIVATION TREES</h2>

<p>Since we need to build these trees in the store of our machines, it makes sense to make them as small as possible without losing the equivalence to the derivation.</p>

<p>The correctness of these reduction strategies consists in you showing how to recover the original derivation from the new tree.</p>

<p>(Easy? Hard?)</p>

<!-- Image -->
<p><img class="centre" src="/assets/project/theory/L02P029A_Derivation1.png" alt="Lecture 02 Image Page 29A" /></p>

<p>No point in saving the values in boxes.  Redundant.</p>

<p>This is chain reduction.</p>

<!-- Image -->
<p><img class="centre" src="/assets/project/theory/L02P029B_Derivation2.png" alt="Lecture 02 Image Page 29B" /></p>

<!-- 30 -->

<h2 id="full-reduction">FULL REDUCTION</h2>

<p>No need to store terminals on trees.  Instead, label nodes with them.</p>

<!-- Diagram here -->
<p><img class="centre" src="/assets/project/theory/L02P030A_FullReduction1.png" alt="Lecture 02 Image Page 30A" /></p>

<p>becomes</p>

<!-- Diagram here -->
<p><img class="centre" src="/assets/project/theory/L02P030B_FullReduction2.png" alt="Lecture 02 Image Page 30B" /></p>

<p>from</p>

<!-- Diagram here -->
<p><img class="centre" src="/assets/project/theory/L02P030C_FullReduction3.png" alt="Lecture 02 Image Page 30C" /></p>

<!-- 31 -->

<p>Let \( \enspace G = \{ N, T, P, s \} \)</p>

<p>Let \( \enspace \alpha, \beta \in S^+ \quad and \quad n \in N \)</p>

<p>\( G \) is SELF-EMBEDDING when there exists \( \enspace \alpha, \beta, n \enspace \) such that \( \enspace  n \Rightarrow^+ \alpha n \beta \)</p>

<h3 id="proposition">Proposition</h3>

<p>If \( G \) is not a self-embedding CFG, then \( L(G) \) is regular.</p>

<p>Note this condition is sufficient but by no means necessary.</p>

<p>This property allows us to isolate those parts of a grammar which are regular.</p>

<!-- 32  -->

<h2 id="regular-grammars">REGULAR GRAMMARS</h2>

<p>In particular the so called MICROSYNTAX of languages which is concerned with the grouping of individual characters into words - identifiers, numbers, reserved words, operators, etc.</p>

<h3 id="example-4">EXAMPLE</h3>

<!-- Started using \; instead of \enspace -->

<p>\( L \; \rightarrow \; \mathrm{a} \; | \; \ldots \; | \; \mathrm{z} \; | \; \mathrm{A} \; | \; \ldots \; | \; \mathrm{Z} \)</p>

<p>\( N \; \rightarrow \; 0 \; | \; \ldots \; | \; 9 \)</p>

<p>\( C \; \rightarrow \; + \; | \; - \; | \; &gt; \; | \; &lt; \; | \; = \)</p>

<p>\( M \; \rightarrow \; L \; | \; N \; | \; - \)</p>

<p>\( Iden \; \rightarrow \; L \; | \; Iden \; M  \)</p>

<p>\( Numb \; \rightarrow \; N \; | \; Numb \; N \)</p>

<p>This is a non-embedding CFG not a RG but can easily be written as such - Do it.</p>

<p>\( Iden \; \rightarrow \; \mathrm{a} \; | \; \ldots \; | \; \mathrm{z} \; | \; \mathrm{A} \; | \; \ldots \; | \; \mathrm{Z} \; | \; \mathrm{a} \; M \; | \; \ldots \; | \; \mathrm{z} \; M \; | \; \mathrm{A} \; M \; | \; \ldots \; | \; \mathrm{Z} \; M  \)</p>

<p>\( Num \; \rightarrow \; 0 \; | \; \ldots \; | \; 9 \; | \; 0 \; Num \; | \; \ldots \; | \; 9 \; Num \)</p>

<p>\( M \; \rightarrow \; Iden \; | \; Num \; | \; - \)</p>

</div>
    </div>
</article>
</div>

      <!-- End Content -->
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>


  </body>
</html>
